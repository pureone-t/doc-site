---
title: fpinscala
date: 2019-01-10T18:30:00+09:00
showDate: true
tags: ["Scala"]
---

関数型プログラミングにおける副作用の除去は、結果型に副作用の元となるデータを返す
入力Aに対する出力Bを返す関数 `f: A => B` は、内部・外部プロセスの変化に影響されない（＝副作用がない）
buyCoffeの例では、請求処理という副作用を出力から排除すること

## 参照透過性
- 同じ条件を与えれば必ず同じ結果が得られる
- 他のいかなる機能の結果にも影響を与えない
- 関数の結果型に従い、実行する全てのことがその戻り値によって表されるという不変条件
- プログラムによる等式推論(`equational reasoning`)が可能

```
def add1(x: Int, y: Int): Int = x + y
```

```
var x: Int = 1
def add2(y: Int): Int = x + y
```

### 参照透過性の確認フロー
#### 例１
```
val x = "Hello World"
val r1 = x.reverse
// dlroW olleH
val r2 = x.reverse
// dlroW olleH
```
- `r1`、`r2`は同じ
- `x`を`x`が参照している式（その定義）と置き換える
```
val r1 = "Hello World".reverse
// dlroW olleH
val r2 = "Hello World".reverse
// dlroW olleH
```
- `r1`、`r2`は同じ
- 置き換えても結果に影響を与えない

#### 例２
```
val x = new StringBuilder("Hello")
val y = x.append(" World")
val r1 = y.toString
// Hello World
val r2 = y.toString
// Hello World
```
- `r1`、`r2`は同じ
- `y`を`y`が参照している式（その定義）と置き換える
```
val x = new StringBuilder("Hello")
val r1 = x.append(" World"").toString
// Hello World
val r2 = x.append(" World"").toString
// Hello World World
```

## unzip

## reduce

## List.fill

## 単相関数(monomorphic function)
- １つの型のデータだけをを操作する関数

## 多相関数(polymorphic function)
- 総称関数(generic function)とも呼ばれる

## 関数リテラル
```
val f2 = (a: Int)
```

## 高階関数パラメータ名

- 引数に関数をとる関数
- 結果型を関数とする関数
- f,g,hのような名称にするのが一般的

## 末尾再帰のオーバーライド
- サブクラスで末尾再帰のメソッドをオーバーライドしようとするとコンパイルエラー
- private final をつける
http://www.ne.jp/asahi/hishidama/home/tech/scala/annotation/tailrec.html

## 関数型データ構造の定義
- データコンストラクタ


## 反変（contravariant）
狭い型から、広い型へ変換

反変バリデーター

```
```

# 第3章 関数型プログラミングのデータ構造

```Scala
def foldRight[A, B](as: List[A], z: B)(f: (A, B) => B): B = as match {
  case Nil => z
  case Cons(x, xs) => f(x, foldRight(xs, z)(f))
}
def sum2(ns: List[Int]): Int = foldRight(ns, 0)(_ + _)
```

```
// Program Trace
foldRight(List(1,2,3,4,5), 0)(_+_)
foldRight(Cons(1, Cons(2, Cons(3, Cons(4, Cons(5, 0))))))(_ + _)
f(1 + foldRight(Cons(2, Cons(3, Cons(4, Cons(5, 0))))))(_ + _)
f(1 + f(2 + foldRight(Cons(3, Cons(4, Cons(5, 0))))))(_ + _)
f(1 + f(2 + f(3 + foldRight(Cons(4, Cons(5, 0))))))(_ + _)
f(1 + f(2 + f(3 + f(4 + foldRight(Cons(5, 0))))))(_ + _)
f(1 + f(2 + f(3 + f(4 + f(5 + 0)))))(_ + _)
f(1 + f(2 + f(3 + f(4 + 5))))(_ + _)
f(1 + f(2 + f(3 + 9)))(_ + _)
f(1 + f(2 + 12))(_ + _)
f(1 + 14)(_ + _)
15
```

```
// Program Trace
foldRight(List(1,2,3,4,5), Nil: List[Int])(Cons(_,_))
foldRight(Cons(1, Cons(2, Cons(3, Cons(4, Cons(5, Nil: List[Int]))))))(Cons(_,_))
f(1, foldRight(Cons(2, Cons(3, Cons(4, Cons(5, Nil: List[Int]))))))(Cons(_,_))
f(1, f(2, foldRight(Cons(3, Cons(4, Cons(5, Nil: List[Int]))))))(Cons(_,_))
f(1, f(2, f(3, foldRight(Cons(4, Cons(5, Nil: List[Int]))))))(Cons(_,_))
f(1, f(2, f(3, f(4, foldRight(Cons(5, Nil: List[Int]))))))(Cons(_,_))
f(1, f(2, f(3, f(4, f(5, Nil: List[Int])))))(Cons(_,_))
f(1, f(2, f(3, f(4, Cons(5, Nil: List[Int])))))(Cons(_,_))
f(1, f(2, f(3, Cons(4, Cons(5, Nil: List[Int])))))(Cons(_,_))
f(1, f(2, Cons(3, Cons(4, Cons(5, Nil: List[Int])))))(Cons(_,_))
f(1, Cons(2, Cons(3, Cons(4, Cons(5, Nil: List[Int])))))(Cons(_,_))
Cons(1, Cons(2, Cons3, Cons(4, Cons(5, Nil: List[Int]))))
```

```Scala
def foldLeft[A, B](as: List[A], b: B)(f: (B, A) => B): B = as match {
  case Nil => b
  case Cons(a, xs) => foldLeft(xs, f(b, a))(f)
}
```

```
// Program Trace
foldLeft(List(1,2,3,4,5), 0)(_+_)
foldLeft(Cons(1, Cons(2, Cons(3, Cons(4, Cons(5, Nil))))), 0)(_+_)
foldLeft(Cons(2, Cons(3, Cons(4, Cons(5, Nil))))), 0+1)(_+_)
foldLeft(Cons(3, Cons(4, Cons(5, Nil))), 1+2)(_+_)
foldLeft(Cons(4, Cons(5, Nil)), 3+3)(_+_)
foldLeft(Cons(5, Nil), 6+4)(_+_)
10+5
```

```Scala
def reverse[A](l: List[A]): List[A] =
  foldLeft(l, List[A]())((b, a) => Cons(a, b))
```

```
// Program Trace
reverse(List(1,2,3,4,5))
foldLeft(List(1,2,3,4,5), List())((b, a) => Cons(a, b))
foldLeft(Cons(1, Cons(2, Cons(3, Cons(4, Cons(5, Nil)))), List())((b, a) => Cons(a, b))
foldLeft(Cons(2, Cons(3, Cons(4, Cons(5, Nil)))), Cons(1, Nil))((b, a) => Cons(a, b))
foldLeft(Cons(3, Cons(4, Cons(5, Nil))), Cons(2, Cons(1, Nil)))((b, a) => Cons(a, b))
foldLeft(Cons(4, Cons(5, Nil)), Cons(3, Cons(2, Cons(1, Nil))))((b, a) => Cons(a, b))
foldLeft(Cons(5, Nil), Cons(4, Cons(3, Cons(2, Cons(1, Nil)))))((b, a) => Cons(a, b))
Cons(5, Cons(4, Cons(3, Cons(2, Cons(1, Nil)))))
```

```Scala
def foldRightViaFoldLeft2[A, B](l: List[A], z: B)(f: (A, B) => B): B =
  foldLeft(l, (b: B) => b)((g, a) => b => g(f(a, b)))(z)
```

```
// Program Trace
- id: (b: B) => b

foldRightViaFoldLeft2(List(1,2,3,4,5), 0)(_+_)
foldLeft(Cons(2, Cons(3, Cons(4, Cons(5, Nil)))), id)((g, a) => b => g(f(a, b)))(z)
foldLeft(Cons(2, Cons(3, Cons(4, Cons(5, Nil)))), id)((id, 1) => b => id(1 + b))(z) // g=id, a=1, res b => b + 1
foldLeft(Cons(3, Cons(4, Cons(5, Nil))), id)((id, 1) => b => id(f(b + 1)))(0)
```

```Scala
def append2[A](al: List[A], bl: List[A]): List[A] =
  foldRight(al, bl)(Cons(_,_))
```

```
// Program Trace
append2(List(1,2,3,4,5), List(6,7,8,9,10))
foldRight(Cons(1, Cons(2, Cons(3, Cons(4, Cons(5, Nil))))), Cons(6, Cons(7, Cons(8, Cons(9, Cons(10, Nil))))))(Cons(_,_))
f(1, foldRight(Cons(2, Cons(3, Cons(4, Cons(5, Nil))))), Cons(6, Cons(7, Cons(8, Cons(9, Cons(10, Nil))))))(Cons(_,_))
f(1, f(2, foldRight(Cons(3, Cons(4, Cons(5, Nil))))), Cons(6, Cons(7, Cons(8, Cons(9, Cons(10, Nil))))))(Cons(_,_))
f(1, f(2, f(3, foldRight(Cons(4, Cons(5, Nil))))), Cons(6, Cons(7, Cons(8, Cons(9, Cons(10, Nil))))))(Cons(_,_))
f(1, f(2, f(3, f(4, foldRight(Cons(5, Nil))))), Cons(6, Cons(7, Cons(8, Cons(9, Cons(10, Nil))))))(Cons(_,_))
f(1, f(2, f(3, f(4, f(5, Nil))))),Cons(6, Cons(7, Cons(8, Cons(9, Cons(10, Nil))))))(Cons(_,_))
f(1, f(2, f(3, f(4, f(5, Cons(6, Cons(7, Cons(8, Cons(9, Cons(10, Nil)))))))))(Cons(_,_))
f(1, f(2, f(3, f(4, Cons(5, Cons(6, Cons(7, Cons(8, Cons(9, Cons(10, Nil)))))))))(Cons(_,_))
f(1, f(2, f(3, Cons(4, Cons(5, Cons(6, Cons(7, Cons(8, Cons(9, Cons(10, Nil)))))))))(Cons(_,_))
f(1, f(2, Cons(3, Cons(4, Cons(5, Cons(6, Cons(7, Cons(8, Cons(9, Cons(10, Nil)))))))))(Cons(_,_))
f(1, Cons(2, Cons(3, Cons(4, Cons(5, Cons(6, Cons(7, Cons(8, Cons(9, Cons(10, Nil)))))))))(Cons(_,_))
Cons(1, Cons(2, Cons(3, Cons(4, Cons(5, Cons(6, Cons(7, Cons(8, Cons(9, Cons(10, Nil)))))))))(Cons(_,_))
```
